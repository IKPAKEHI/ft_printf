#include <stdio.h>

// int main(int argc, char const *argv[])
// {
// 	// printf("%+012d\n",999);
// 	// printf("%.12d\n",888);
// 	// printf("%012.4d\n",777);
// 	// printf("%012x\n",255);
// 	// printf("%-012d|\n",256);
// 	// printf("% -12d|\n",222);
// 	// printf("% 12d|\n",222);
// 	// printf("%+5d|\n",-223);
// 	//printf("|%*.*d|\n",100,10, 5);
// 	// printf("%-12d|\n", -222);
// 	// printf("%012.4d\n", 1);
// 	// printf("\n");
// 	// printf("%05.4i\n", 1000);
// 	// printf("%c\n", 's');
// 	// printf("%*d\n",111);
// 	// printf("%.1s\n", "asd");
// 	// printf("%.5x\n", 510);

// 	printf("%.5d|\n",-255);
// 	printf("%.2f\n", 123.123);
// 	//printf("%#-0d", 5);
// 	return 0;
// }


	// if (c == '-')
	// 	(*formatt)->flags[0] = 1;
	// if (c == '+')
	// 	(*formatt)->flags[1] = 1;
	// if (c == ' ')
	// 	(*formatt)->flags[2] = 1;
	// if (c == '#')
	// 	(*formatt)->flags[3] = 1;
	// if (c == '0')
	// 	(*formatt)->flags[4] = 1;

//1) флаги #0+- *space*
//2) - важнее *space* и 0
//3) если флаги поместить в любую точку ред.с. после width она их пропустит
//4) между флагами возможно любое количество пробелов
//5) флаги могут повторятся (повтооры упускаются)
//6) *space* доставляет 1 пробел и не для знаковых
//7) + только для десятичных

//1) ширина десятичное число или символ *
//2) ширина доставляет space или 0 для флага (0) (ширина - длинна числа)
//3) ширина доставляет space (ширина - длинна строки)
//4) если присутствует * для неё считывается аргумент
//5) приоритет между числом и * в зависимости от того что первое
//6) последующие символы * игнорируются

//1) точность десятичное число или * после точки
//2) для строки указывает количество выводимых символов, если больше длинны строки выводится сама строка
//3) для чисел доставляет предшествующие 0 но только если длинна числа меньше числа точности


//если число негативное флаг space и + игнорируются
//если есть флаг - то флаг 0 игнорируестя
//если есть флаг 0 и указана точность, 0 игнорируется
//ширина имеет приоритет только если точность меньше



if (**str == 'h' && *(*str + 1) == 'h')   //unsigned char
		(*formatt)->type = 1;
	if (**str == 'h' && *(*str + 1) != 'h') //unsigned short
		(*formatt)->type = 2;
	if (**str == 'l' && *(*str + 1) == 'l') //unsigmed long long
		(*formatt)->type = 3;
	if (**str == 'l' && *(*str + 1) != 'l') //unsigned long
		(*formatt)->type = 4;
	if (**str == 'j')
		(*formatt)->type = 5;  //long int
	if (**str == 'z')
		(*formatt)->type = 6;
	if ((*formatt)->type == 3 || (*formatt)->type == 1)
		(*str)++;